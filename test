
def spawn_ray(pixel_coords_x, pixel_coords_y, camera_view_matrix):
    ...


def is_inside_unit_cube(point):
    return jnp.logical_and(jnp.all(point <= 0.5), jnp.all(point >= -0.5))


def convert_position_to_voxel_indices(position, subdivisions):
    voxel_indices = jnp.floor(
        (position + 0.5) / (1 / subdivisions)
    ).astype(int)

    return voxel_indices


def get_ray_origin(ray_origin, ray_direction):
    return ray_origin


def compute_intersection_point_from_outside(ray_origin, ray_direction):
   ...


def get_first_intersection_with_voxel_grid(ray_origin, ray_direction):
    return lax.cond(is_inside_unit_cube(ray_origin), get_ray_origin,
                    compute_intersection_point_from_outside, ray_origin, ray_direction)


def getBackgroundColor(intersection_point, ray_direction, voxel_grid):
    return jnp.zeros(4)


def compute_voxel_color(voxel_indices, voxel_grid):
    return voxel_grid[voxel_indices[0], voxel_indices[1], voxel_indices[2]]


def ray_stopped_by_occlusion(current_color):
    return current_color[3] > 0.99


def blend(current_color, local_color):
    ...


def get_subdivisions(voxel_grid):
    return voxel_grid.shape[0]


def ray_voxel_traversal(intersection_point, ray_direction, voxel_grid):
    subdivisions = get_subdivisions(voxel_grid)

    # Convert the intersection point to the index of the hit voxel
    voxel_indices = convert_position_to_voxel_indices(intersection_point, subdivisions)

    voxel_size = 1 / subdivisions

    # Implement DDA algorithm for ray voxel traversal here:
    step = jnp.sign(ray_direction)

    step_between_0_and_1 = jnp.clip(step, 0, 1)

    t_max = jnp.where(
        step == 0,
        jnp.inf,
        ((voxel_indices + step_between_0_and_1) * voxel_size - 0.5 - intersection_point) / ray_direction
    )

    t_delta = jnp.where(
        step == 0,
        jnp.inf,
        voxel_size / jnp.abs(ray_direction)
    )

    def valid_grid_indices(voxel_indices):
        return jnp.all(jnp.logical_and(voxel_indices >= 0, voxel_indices < subdivisions))

    def cond_fun(carry):
        voxel_indices, t_max, color = carry
        return jnp.logical_and(jnp.logical_not(ray_stopped_by_occlusion(color)),
                               valid_grid_indices(voxel_indices))

    def body_fun(carry):
        voxel_indices, t_max, color = carry

        # Update voxel indices and t_max based on the minimum t_max component
        axis = jnp.argmin(t_max)
        voxel_indices = voxel_indices.at[axis].add(step[axis])
        t_max = t_max.at[axis].add(t_delta[axis])

        def get_updated_ray_color(current_color):
            local_color = compute_voxel_color(voxel_indices, voxel_grid)

            return blend(current_color, local_color)

        color = lax.cond(valid_grid_indices(voxel_indices), get_updated_ray_color, lambda current_color: current_color,
                         color)

        return voxel_indices, t_max, color

    # Initialize the carry variables
    color = compute_voxel_color(voxel_indices, voxel_grid)
    carry = (voxel_indices, t_max, color)

    # Run the while loop using lax.while_loop
    voxel_indices, t_max, color = lax.while_loop(cond_fun, body_fun, carry)

    return color


def trace_ray(ray_origin, ray_direction, voxel_grid):
    intersection_point = get_first_intersection_with_voxel_grid(ray_origin, ray_direction)

    no_intersection = jnp.all(jnp.equal(intersection_point, jnp.array([-1.0, -1.0, -1.0])))

    return lax.cond(no_intersection, getBackgroundColor, ray_voxel_traversal,
                    intersection_point, ray_direction, voxel_grid)


def render_pixel(x, y, camera_view_matrix, voxel_grid):
    origin, direction = spawn_ray(x, y, camera_view_matrix)
    color = trace_ray(origin, direction, voxel_grid)
    return color


@jit
def render(camera_view_matrix, voxel_grid):
    pixel_coords = jnp.meshgrid(jnp.arange(image_width), jnp.arange(image_height))
    pixel_coords = jnp.stack(pixel_coords, axis=-1).reshape(-1, 2)

    def render_fn(coords):
        return render_pixel(coords[0], coords[1], camera_view_matrix, voxel_grid)

    image = vmap(render_fn)(pixel_coords)[:, :3].reshape(image_height, image_width, 3)
    return image


def main():
    camera_view_matrix = ...

    image = render(camera_view_matrix)
--- Instruction: I want to get compare the rendered image with the original image and then compute the gradient back to the voxel grid and update that with stochastic gradient decent. Can you explain to me what steps I would need to take to enable this in my small JAX project here?